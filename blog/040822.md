---
title: Day 60 - Getting acquainted with Makefiles! ğŸ¥¡
date: 2022-04-08
description: Because I suppose I need this in my life.
tags: c++, Makefile
---

# {{ $page.title }}

I think I get makefiles, except for some parts which I do not understand. As with everything in life, really, which will for sure follow this formula. As of now, I need to have a proper grasp on it to implement the testing c++ framework; I want to finally be able to understand esoteric looking stuff like `OBJS:= $(SRCS:%.cpp=$(DIR_O)/%.o)`, and how to make it recompile only changed dependencies. It must not be impossible, right? So I'm following [this tutorial](https://makefiletutorial.com/), and jumping into some GNU documentation rabbitholes. ğŸ° 

## Some stuff to remember later

### Definition of a rule ğŸ“
I'm quoting very early in the GNU documentation. About rules,

::: tip Definition of rules
A rule appears in the makefile and says when and how to remake certain files, called the ruleâ€™s targets (most often only one per rule). It lists the other files that are the prerequisites of the target, and the recipe to use to create or update the target.
:::

This is important, because my compilation will usually recompile all the dependencies, even though the source code might have not changed.

Plus, we have that `The criterion for being out of date is specified in terms of the prerequisites, which consist of file names separated by spaces. A target is out of date if it does not exist or if it is older than any of the prerequisites (by comparison of last-modification times). `

### What's a Phony? ğŸ¤¡

Now, phony is not just a light insult on frauds; it is a special way to declare that a target doesn't necessarily generate a file. This is useful, since Makefiles check whether the prerequisites of a file are newer than the target; it avoids running the rule otherwise. The GNU documentation has a great example on a `clean` rule, that removes object files (and has no prerequisites). If there is a file named `clean`, the rule will never run â€” since there are no prerequisites, and the target file *exists*, `make` will skip its execution. Funny stuff!

```makefile
.PHONY: clean
clean:
	rm *.o temp
```

### Static patterns, or *am I smart enough to understand this?* ğŸ¤”

So we get to the crux of Makefiles for me. Here follows the syntax of static patterns:

```
targets â€¦: target-pattern: prereq-patterns â€¦
        recipe
        â€¦
``` 

And, quoting directly from the [GNU documentation](https://www.gnu.org/software/make/manual/make.html#Static-Pattern)  

*Each pattern normally contains the character â€˜%â€™ just once. When the target-pattern matches a target, the â€˜%â€™ can match any part of the target name; this part is called the stem. The rest of the pattern must match exactly. For example, the target foo.o matches the pattern â€˜%.oâ€™, with â€˜fooâ€™ as the stem. The targets foo.c and foo.out do not match that pattern.*

*The prerequisite names for each target are made by substituting the stem for the â€˜%â€™ in each prerequisite pattern. For example, if one prerequisite pattern is %.c, then substitution of the stem â€˜fooâ€™ gives the prerequisite name foo.c. It is legitimate to write a prerequisite pattern that does not contain â€˜%â€™; then this prerequisite is the same for all targets.*

Well, so far so good. In the following example, there's some use of the [automatic variables](https://www.gnu.org/software/make/manual/make.html#Automatic-Variables). `$<` and `$@`, which will hold the name of the prerequisite and the name of the target, respectively.

```
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@
```

<FetchComments :title=$frontmatter.title />
<PostComments :title=$frontmatter.title />
